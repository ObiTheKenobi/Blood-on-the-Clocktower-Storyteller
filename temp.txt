## MATRIX CALCULATIONS ##
import numpy as np
import pandas as pd
import pymc as pm
from pulp import LpProblem, LpVariable, LpMinimize, lpSum, LpBinary, value
import sqlite3
import math
import random
# from WebConnection import webSetUp
import db_setup
from character_constraints import character_constraints

def assignments(script_name, player_list):
    # Connect to db
    try:
        con = sqlite3.connect(db_setup.db_path)
        cur = con.cursor() 
    except Exception as e:
        print(f'An error occurred: {e}.')
        exit()

    query = """
    SELECT *
    FROM players
    WHERE name IN ({})
    """.format(','.join(['?'] * len(player_list)))

    cur.execute(query, tuple(player_list))
    rows = cur.fetchall() 

    # Convert output into lists
    a, b, c, d = zip(*rows)
    player_ids = list(a)
    player_names = list(b)
    players_elo_good = list(c)
    players_elo_evil = list(d)


    # Create dataframe to store info
    players = pd.DataFrame({
        'player_id': player_ids,
        'name': player_names,
        'elo_good': players_elo_good,
        'elo_evil': players_elo_evil
    })



    # Get players recent team history
    recent_history = {}
    for player in player_ids:
        query = """
        SELECT player_id, team 
        FROM assignments
        WHERE player_id = ?
        ORDER BY assignment_id DESC
        LIMIT 10;
        """
        cur.execute(query, (player,))
        rows = cur.fetchall()
        try:
            a, b = zip(*rows)
            team_for_player = list(b)
        except:
            team_for_player = ['Good', 'Good', 'Good', 'Good', 'Good', 'Good', 'Good', 'Good', 'Good', 'Good']
        recent_history[player] = team_for_player



    sql = """
    SELECT character_id, name, alignment, role_type, base_strength
    FROM characters RIGHT JOIN script_characters USING (character_id)
    WHERE script_id = (
    SELECT script_id
    FROM scripts
    WHERE scripts.name = ?);
    """
    cur.execute(sql, (script_name,))
    rows = cur.fetchall()

    a, b, c, d, e = zip(*rows)
    char_ids = list(a)
    char_names = list(b)
    char_alignments = list(c)
    char_types = list(d)
    char_strengths = list(e)


    # Set up characters dataframe
    characters = pd.DataFrame({
        'character_id': char_ids,
        'name': char_names,
        'alignment': char_alignments,
        'base_strength': char_strengths,
        'role_type': char_types
        
    })
    characters = characters.sample(frac=1).reset_index(drop=True)
    query = """
    SELECT player_id, character_id, team, won
    FROM assignments
    WHERE player_id IN ({})
    AND character_id IN ({})""".format(','.join(['?'] * len(player_ids)),
                                       ','.join(['?'] * len(char_ids)))
    cur.execute(query, tuple(player_ids + char_ids))
    rows = cur.fetchall()

    a, b, c, d = zip(*rows)
    player_ids_assign = list(a)
    char_ids_assign = list(b)
    team_assign = list(c)
    won_assign = list(d)


    query = """
    SELECT *
    FROM type_distribution
    WHERE num_players = ?;
    """
    num_players = len(player_list)
    cur.execute(query, (num_players,))
    num_types = cur.fetchall()
    con.close()
  

    # Set up previous game data outcomes
    game_data = pd.DataFrame({
        'player_id': player_ids_assign,
        'character_id': char_ids_assign,
        'alignment': team_assign,
        'won': won_assign
    })


    ## Normalise elo to be centred around 1500
    def normaliseElo(elo):
        return (elo - 1500) / 400 

    ## Normalise base strenght to be centred around 50
    def normaliseBaseStrength(base_strength):
        return (base_strength - 50) / 25

    ## Get a players normalised elo for their alignment
    def getNormalisedElo(row):
        player = players.loc[players['player_id'] == row['player_id']].iloc[0]
        if row['alignment'] == 'Good':
            return normaliseElo(player['elo_good'])
        else:
            return normaliseElo(player['elo_evil'])


    game_data['normalized_elo'] = game_data.apply(getNormalisedElo, axis=1)

    ## Get a characters normalised strength from their id
    def getNormalisedStrength(cid):
        strength = characters.loc[characters['character_id'] == cid, 'base_strength'].values[0]
        return normaliseBaseStrength(strength)



    ### Generate win probability matrix S[i][j] ###
    ## Sigmoid function
    def sigmoid(x, steepness=1.5, midpoint=3):
        return 1 / (1 + np.exp(steepness * (x - midpoint)))

    ## If a player has been good more often, add bias towards being evil and vice versa
    def get_alignment_bias(player_id, target_alignment):
        history = recent_history.get(player_id, [])
        bias = 0

        if target_alignment == 'Good':
            recent_evil = history[:2].count('Evil')
            consecutive_evil = 0
            for align in history:
                if align == 'Evil':
                    consecutive_evil += 1
                else:
                    break

            base = 0.5 + 0.3 * recent_evil + 0.2 * consecutive_evil
            noise = random.uniform(-1.5, 1.5)
            bias = base + noise

        elif target_alignment == 'Evil':
            good_streak = 0
            for align in history:
                if align == 'Good':
                    good_streak += 1
                else:
                    break

            # Logistic decay
            decay = 1 / (1 + math.exp(1.2 * (good_streak - 3)))
            noise = random.uniform(0.3, 1.0)
            base = 0.3 + decay * noise

            # Add in a random element to ensure that the assignments are not predictable
            bias = base + random.uniform(0.05, 0.2)

        return round(bias, 3)
    game_data['normalized_strength'] = game_data['character_id'].map(getNormalisedStrength)
        ## CONSTRAINT: the number of each role type must match the script requirements
    player_requirements = {
        'Townsfolk': num_types[0][1],
        'Outsider': num_types[0][2],
        'Minion': num_types[0][3],
        'Demon': num_types[0][4]
    }

    # Start with defaults, then apply character-specific adjustments
    adjusted_requirements = dict(player_requirements)
    accept = False
    while not accept:
        ## Building Bayesian logicistic model
        with pm.Model() as model:
            weighted_elo = pm.Normal('weighted_elo', mu=1, sigma=3)
            weighted_strength = pm.Normal('weighted_strength', mu=1, sigma=3)
            intercept = pm.Normal('intercept', mu=0, sigma=1)

            theta = pm.Data('theta', game_data['normalized_elo'].values)
            phi = pm.Data('phi', game_data['normalized_strength'].values)

            logits = (weighted_elo * theta) + (weighted_strength * phi) + intercept
            p = pm.Deterministic('p', pm.math.sigmoid(logits))

            outcome = pm.Bernoulli('outcome', p=p, observed=game_data['won'].values)
            map_estimate = pm.find_MAP()

        weighted_elo = map_estimate['weighted_elo']
        weighted_strength = map_estimate['weighted_strength']
        intercept = map_estimate['intercept']



        num_players = len(players)
        num_characters = len(characters)

        prob = LpProblem("CharacterAssignment", LpMinimize)
        x = [[LpVariable(f"x_{i}_{j}", cat=LpBinary) for j in range(num_characters)] for i in range(num_players)]

        # --- Each player gets exactly one character ---
        for i in range(num_players):
            prob += lpSum(x[i][j] for j in range(num_characters)) == 1

        # --- Each character is assigned to at most one player ---
        for j in range(num_characters):
            prob += lpSum(x[i][j] for i in range(num_players)) <= 1

        # --- Apply character-specific constraints ONCE, collect hooks ---
        hooks = []
        for char_name, fn in character_constraints.items():
            if char_name in characters['name'].values:
                char_index = characters[characters['name'] == char_name].index[0]
                result = fn(prob, x, characters, players, player_requirements, char_index)
                if "_log" in result:
                    print(f"[Constraint Applied] {result['_log']}")
                if "_hook" in result:
                    hooks.append(result["_hook"])
                # remove meta-entries before merging counts
                result.pop("_log", None)
                result.pop("_hook", None)
                adjusted_requirements.update(result)

        # --- Run hooks BEFORE building S/B (so balance math uses mutated characters) ---
        for hook in hooks:
            msg = hook(characters, players)
            print(f"[Balance Adjustment] {msg}")

        # --- Build S (win probability contributions) and B (bias) with any hook changes applied ---
        S = np.zeros((num_players, num_characters))
        B = np.zeros((num_players, num_characters))

        for i, player in players.iterrows():
            for j, character in characters.iterrows():
                elo = player['elo_good'] if character['alignment'] == 'Good' else player['elo_evil']
                norm_elo = normaliseElo(elo)
                norm_strength = normaliseBaseStrength(character['base_strength'])

                logit = weighted_elo * norm_elo + weighted_strength * norm_strength + intercept
                win_prob = 1 / (1 + np.exp(-logit))

                # Add small random jitter (e.g. Â±0.01)
                jitter = np.random.uniform(-0.05, 0.05)
                S[i][j] = win_prob + jitter

                bias = get_alignment_bias(player['player_id'], character['alignment'])
                B[i][j] = bias

        # --- Enforce adjusted role requirements ---
        for role_type in ['Townsfolk', 'Outsider', 'Minion', 'Demon']:
            role_mask = [1 if characters.loc[j, 'role_type'] == role_type else 0 for j in range(num_characters)]
            role_count = lpSum(x[i][j] * role_mask[j] for i in range(num_players) for j in range(num_characters))
            required_count = adjusted_requirements.get(role_type, player_requirements[role_type])
            prob += role_count == required_count

        # --- Optional: cap usage of each role type (safety for duplicate entries) ---
        role_usage_caps = {}
        for role_type, required_count in player_requirements.items():
            available = sum(1 for j in range(num_characters) if characters.loc[j, 'role_type'] == role_type)
            temp = int(np.ceil(required_count / available)) if available > 0 else required_count
            role_usage_caps[role_type] = temp

        for j in range(num_characters):
            role = characters.loc[j, 'role_type']
            usage_cap = role_usage_caps.get(role, 1)
            prob += lpSum(x[i][j] for i in range(num_players)) <= usage_cap

      # --- Team balance constraint with tolerance and randomness ---

        # Shuffle characters to break deterministic tie-breaks
                # characters = characters.sample(frac=1).reset_index(drop=True)
        # --- Team balance constraint with tolerance ---
        team_sign = [1 if characters.loc[j, 'alignment'] == 'Good' else -1 for j in range(num_characters)]

        good_total = lpSum(x[i][j] * S[i][j] for i in range(num_players) for j in range(num_characters) if team_sign[j] == 1)
        evil_total = lpSum(x[i][j] * S[i][j] for i in range(num_players) for j in range(num_characters) if team_sign[j] == -1)

        num_good = sum(1 for j in range(num_characters) if team_sign[j] == 1)
        num_evil = sum(1 for j in range(num_characters) if team_sign[j] == -1)

        av_good = good_total / num_good if num_good > 0 else 0
        av_evil = evil_total / num_evil if num_evil > 0 else 0

        # Bias score
        bias_score = lpSum(x[i][j] * B[i][j] for i in range(num_players) for j in range(num_characters))

        # Allow imbalance up to tolerance
        tolerance = 1.0
        excess = LpVariable("excess_imbalance", lowBound=0)

        prob += av_good - av_evil <= tolerance + excess
        prob += av_evil - av_good <= tolerance + excess

        # --- Objective ---
        objective = excess - bias_score

        # Optional: encourage Baron
        if "Baron" in characters['name'].values:
            baron_index = characters[characters['name'] == 'Baron'].index[0]
            baron_var = lpSum(x[i][baron_index] for i in range(num_players))
            # Scale incentive to match bias_score magnitude
            objective -= 50000 * baron_var

        # Add small random jitter to break ties
        noise = lpSum(np.random.uniform(-0.5, 0.5) * x[i][j]
                    for i in range(num_players) for j in range(num_characters))
        objective += noise

        prob += objective
        prob += 0
        # --- Solve ---
        prob.solve()

        # Debugging
        print("Objective components:")
        print("  Excess imbalance:", value(excess))
        print("  Bias score:", value(bias_score))
        if "Baron" in characters['name'].values:
            print("  Baron chosen:", value(baron_var))
        # --- Diagnostic summary: final adjusted requirements ---
        print("\n========== Final Adjusted Role Requirements ==========")
        for role_type in ['Townsfolk', 'Outsider', 'Minion', 'Demon']:
            base = player_requirements.get(role_type, 0)
            adjusted = adjusted_requirements.get(role_type, base)
            if adjusted != base:
                print(f"{role_type}: {base} â {adjusted}")
            else:
                print(f"{role_type}: {adjusted} (unchanged)")
        print("======================================================\n")

        # --- Build assignment list with role_type included ---
        assignments = []
        for i in range(num_players):
            for j in range(num_characters):
                if x[i][j].value() == 1:
                    assignments.append({
                        'player': players.loc[i, 'name'],
                        'character': characters.loc[j, 'name'],
                        'role_type': characters.loc[j, 'role_type'],
                        'win_probability': S[i][j],
                        'team': characters.loc[j, 'alignment']
                    })

        assignment_df = pd.DataFrame(assignments)

        # --- Print actual assigned counts ---
        role_counts = {role: 0 for role in ['Townsfolk', 'Outsider', 'Minion', 'Demon']}
        for row in assignments:
            role_counts[row['role_type']] += 1

        print("\nFinal Assignments:")
        print(assignment_df[['player', 'character', 'role_type', 'win_probability', 'team']])

                
        valid_accept = False
        while not valid_accept:
            accept_assign = str(input("Accept assignment? Y/N   ")).upper()
            if accept_assign == "Y":
                accept = True
                valid_accept = True
            elif accept_assign == "N":
                valid_accept = True
            else:
                print("Please enter valid option")

 ## Sample example   
script = "Trouble_brewing"
# players = ["Liza","Madi", "Rita", "Pedro", "Jed", "Oli", "Rowan", "Gana"]
players = ["Liza","Madi", "Rita", "Pedro", "Jed", "Oli", "Rowan", "Gana", "Elia", "Alona"]
assignments(script, players)
